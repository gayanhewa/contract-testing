"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.propTypeMap = exports.extractJSDocSchemaProps = void 0;
const types_1 = require("../types");
const util_1 = require("../util");
const errors_1 = require("../errors");
function extractJSDocSchemaProps(jsDoc, type) {
    // return early if there is no jsDoc available
    if (!jsDoc) {
        return;
    }
    const rawDefaults = jsDoc
        .getTags()
        .filter(tag => tag.getTagName() === "default")
        .map(schemaProp => schemaProp.getComment());
    const parentJsDocNode = jsDoc.getParent();
    if (rawDefaults && rawDefaults.indexOf(undefined) !== -1) {
        return util_1.err(new errors_1.ParserError("Default must not be empty", {
            file: parentJsDocNode.getSourceFile().getFilePath(),
            position: parentJsDocNode.getPos()
        }));
    }
    const rawSchemaProps = jsDoc
        .getTags()
        .filter(tag => tag.getTagName() === "oaSchemaProp")
        .map(schemaProp => schemaProp.getComment());
    if (rawSchemaProps && rawSchemaProps.indexOf(undefined) !== -1) {
        return util_1.err(new errors_1.ParserError("schemaProp must not be empty", {
            file: parentJsDocNode.getSourceFile().getFilePath(),
            position: parentJsDocNode.getPos()
        }));
    }
    if (rawDefaults && rawDefaults.length > 0) {
        rawDefaults.every(defaultValue => {
            rawSchemaProps.push("default\n" + defaultValue);
        });
    }
    if (rawSchemaProps && rawSchemaProps.length > 0) {
        const schemaProps = [];
        let schemaPropError;
        const typeSpecified = spotTypesToJSTypesMap.get(type.kind) || type.kind;
        let subTypeSpecified = typeSpecified;
        if (type.kind === types_1.TypeKind.UNION || type.kind === types_1.TypeKind.INTERSECTION) {
            const referenceType = type.types[0].kind;
            if (type.types.every(subType => {
                return subType.kind === referenceType;
            })) {
                subTypeSpecified =
                    spotTypesToJSTypesMap.get(referenceType) || referenceType;
            }
        }
        rawSchemaProps.every(schemaProp => {
            var _a, _b, _c, _d;
            const schemaPropStr = schemaProp === null || schemaProp === void 0 ? void 0 : schemaProp.toString();
            const schemaPropName = (_a = schemaPropStr === null || schemaPropStr === void 0 ? void 0 : schemaPropStr.split("\n")[0]) === null || _a === void 0 ? void 0 : _a.trim();
            const schemaPropValue = (_b = schemaPropStr === null || schemaPropStr === void 0 ? void 0 : schemaPropStr.split("\n")[1]) === null || _b === void 0 ? void 0 : _b.trim();
            if (!schemaPropName || !schemaPropValue) {
                schemaPropError = util_1.err(new errors_1.ParserError("malformed schemaProp", {
                    file: parentJsDocNode.getSourceFile().getFilePath(),
                    position: parentJsDocNode.getPos()
                }));
                return false;
            }
            else {
                if (schemaProps.some(ex => ex.name === schemaPropName)) {
                    schemaPropError = util_1.err(new errors_1.ParserError("duplicate " + schemaPropName + " schemaProp name", {
                        file: parentJsDocNode.getSourceFile().getFilePath(),
                        position: parentJsDocNode.getPos()
                    }));
                    return false;
                }
                if ((((_c = exports.propTypeMap.get(schemaPropName)) === null || _c === void 0 ? void 0 : _c.type) === "string" ||
                    (typeSpecified === types_1.TypeKind.STRING &&
                        ((_d = exports.propTypeMap.get(schemaPropName)) === null || _d === void 0 ? void 0 : _d.type) === "any")) &&
                    (!schemaPropValue.startsWith('"') || !schemaPropValue.endsWith('"'))) {
                    schemaPropError = util_1.err(new errors_1.ParserError(schemaPropName + " schemaProp must be quoted", {
                        file: parentJsDocNode.getSourceFile().getFilePath(),
                        position: parentJsDocNode.getPos()
                    }));
                    return false;
                }
                try {
                    const parsedValue = JSON.parse(schemaPropValue);
                    schemaProps.push({ name: schemaPropName, value: parsedValue });
                }
                catch (e) {
                    schemaPropError = util_1.err(new errors_1.ParserError("could not parse schemaProp", {
                        file: parentJsDocNode.getSourceFile().getFilePath(),
                        position: parentJsDocNode.getPos()
                    }));
                    return false;
                }
                return true;
            }
        });
        if (schemaPropError) {
            return schemaPropError;
        }
        const nameSchemaProps = schemaProps.map(ex => {
            return ex.name;
        });
        if (nameSchemaProps.some(nameSchemaProp => {
            var _a;
            return !((_a = exports.propTypeMap
                .get(nameSchemaProp)) === null || _a === void 0 ? void 0 : _a.targetTypes.find(targetType => targetType === typeSpecified));
        })) {
            return util_1.err(new errors_1.ParserError("property must be compliant with " +
                typeSpecified +
                " type or property not allowed", {
                file: parentJsDocNode.getSourceFile().getFilePath(),
                position: parentJsDocNode.getPos()
            }));
        }
        const typeOf = (value) => {
            const typeOfValue = Object.prototype.toString.call(value);
            const regex = /\[object |\]/g;
            return typeOfValue.replace(regex, "").toLowerCase();
        };
        if (schemaProps.some(schemaProp => {
            var _a, _b, _c;
            return (((_a = exports.propTypeMap.get(schemaProp.name)) === null || _a === void 0 ? void 0 : _a.type) === "any" &&
                typeOf(schemaProp.value) !== subTypeSpecified) ||
                (((_b = exports.propTypeMap.get(schemaProp.name)) === null || _b === void 0 ? void 0 : _b.type) !== "any" &&
                    ((_c = exports.propTypeMap.get(schemaProp.name)) === null || _c === void 0 ? void 0 : _c.type) !== typeOf(schemaProp.value));
        })) {
            return util_1.err(new errors_1.ParserError("property type is wrong", {
                file: parentJsDocNode.getSourceFile().getFilePath(),
                position: parentJsDocNode.getPos()
            }));
        }
        return util_1.ok(schemaProps);
    }
    return;
}
exports.extractJSDocSchemaProps = extractJSDocSchemaProps;
exports.propTypeMap = new Map([
    ["additionalProperties", { type: "boolean", targetTypes: [types_1.TypeKind.OBJECT] }],
    [
        "default",
        {
            type: "any",
            targetTypes: [
                "number",
                types_1.TypeKind.STRING,
                types_1.TypeKind.BOOLEAN,
                types_1.TypeKind.ARRAY,
                types_1.TypeKind.OBJECT
            ]
        }
    ],
    [
        "deprecated",
        {
            type: "boolean",
            targetTypes: [
                "number",
                types_1.TypeKind.STRING,
                types_1.TypeKind.BOOLEAN,
                types_1.TypeKind.ARRAY,
                types_1.TypeKind.OBJECT,
                types_1.TypeKind.UNION,
                types_1.TypeKind.INTERSECTION
            ]
        }
    ],
    [
        "example",
        {
            type: "any",
            targetTypes: [
                "number",
                types_1.TypeKind.STRING,
                types_1.TypeKind.BOOLEAN,
                types_1.TypeKind.ARRAY,
                types_1.TypeKind.OBJECT,
                types_1.TypeKind.UNION,
                types_1.TypeKind.INTERSECTION
            ]
        }
    ],
    ["exclusiveMaximum", { type: "boolean", targetTypes: ["number"] }],
    ["exclusiveMinimum", { type: "boolean", targetTypes: ["number"] }],
    ["maximum", { type: "number", targetTypes: ["number"] }],
    ["maxItems", { type: "number", targetTypes: [types_1.TypeKind.ARRAY] }],
    ["maxLength", { type: "number", targetTypes: [types_1.TypeKind.STRING] }],
    ["maxProperties", { type: "number", targetTypes: [types_1.TypeKind.OBJECT] }],
    ["minimum", { type: "number", targetTypes: ["number"] }],
    ["minItems", { type: "number", targetTypes: [types_1.TypeKind.ARRAY] }],
    ["minLength", { type: "number", targetTypes: [types_1.TypeKind.STRING] }],
    ["minProperties", { type: "number", targetTypes: [types_1.TypeKind.OBJECT] }],
    ["multipleOf", { type: "number", targetTypes: ["number"] }],
    ["pattern", { type: "string", targetTypes: [types_1.TypeKind.STRING] }],
    [
        "title",
        {
            type: "string",
            targetTypes: [
                "number",
                types_1.TypeKind.STRING,
                types_1.TypeKind.BOOLEAN,
                types_1.TypeKind.ARRAY,
                types_1.TypeKind.OBJECT,
                types_1.TypeKind.UNION,
                types_1.TypeKind.INTERSECTION
            ]
        }
    ],
    ["uniqueItems", { type: "boolean", targetTypes: [types_1.TypeKind.ARRAY] }]
]);
const spotTypesToJSTypesMap = new Map([
    [types_1.TypeKind.INT32, "number"],
    [types_1.TypeKind.INT64, "number"],
    [types_1.TypeKind.INT_LITERAL, "number"],
    [types_1.TypeKind.FLOAT, "number"],
    [types_1.TypeKind.FLOAT_LITERAL, "number"],
    [types_1.TypeKind.DOUBLE, "number"],
    [types_1.TypeKind.BOOLEAN_LITERAL, types_1.TypeKind.BOOLEAN],
    [types_1.TypeKind.STRING_LITERAL, types_1.TypeKind.STRING],
    [types_1.TypeKind.DATE, types_1.TypeKind.STRING],
    [types_1.TypeKind.DATE_TIME, types_1.TypeKind.STRING]
]);
